'''
뭔가 계산이 연속적으로 되어있으니까 DP를 떠올려야 될듯??
피보나치도 계속해서 계산이 되는 모양이니까!

그리고 /5,/3,/2,-1의 조합이 무수히 많은데 그중에서 가장 작은 것을 골라야하므로
그리디 방법으로 접근하면 안된다.
'''

x = int(input())
d=[0]*(x+1)

for i in range(2,x+1):

    #무조건 1을 빼는 경우가 있으니까
    d[i] = d[i-1] + 1

    #그리고 2,3,5로 나눠지는 경우를 다 따져보자.
    #이때 2,3,5 순으로 하는 것이 포인트다. 왜냐하면 작은수로 나눌수록 경우가 더 많아지기 때문이라 생각
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

for j in range(1,len(d)):
    print("f({0})의 경우의 수는 {1} 이다.".format(j,d[j]))

print("결국 f({0})의 최단 경우의 수는 {1}이다.".format(x,d[x]))