# 코딩 테스트 준비용 알고리즘 특별 리뷰 모음 :smirk:

표로 문제에 대한 소감을 한줄로 작성하자.

|날짜| 리뷰 |
|:--:|:--:| 
|221007|  14889 : 일반적으로 중복없이 조합을 **순서대로(오름차순 혹은 내림차순)** 구할 땐, DFS와 백트래킹을 이용한 방법이 효율적이다. 단, 순서 없이 조합을 고르는 것은 permutations를 사용하자. :ok_woman: <br/><br/> 14890 : 완전 그냥 구현 문제. 문제 잘 읽고 잘 따라서만 하면 쉽게 풀 수 있는데 계속 세세한거 하나하나를 놓쳐서 시간이 오래걸린다. <br/><br/>  15683 : 이거 까먹었다.. 중요한게 뭐였는지.. <br/><br/> 15684(못품) : **구현 및 시뮬레이션을 할 땐, 최대한 2차원 행렬을 사용하려고 노력하자.** dict을 쓰면 결국 0(N)이 걸리니까 주소를 pointing하는 배열이 훨씬 시간적으로 효율적이다. **-꼭 다시보자. 2차원 행렬을 어떻게 dfs에서 쓸건지 보여준다.**<br/><br/> 16235 : **2차원 행렬에 deque 객체가 들어갈 수 있는 것을 처음 알았다.** 나무의 나이의 순서를 고려해야했던 문제인데, deque를 써서 appendleft를 사용할 수 있었다. 그리고 효율을 추구하기 위해서 계절끼리 묶을 수 있는 것들을 묶어야한다. <br/><br/> 20057 : 나만의 방법으로 **나선형으로 배열을 훑는 것**을 만들었다. 꼭 볼 것. 그리고 문제를 잘 읽고 그대로 따라서 구현하는 것을 꼭 고려하자. **문제 좀 잘 읽자!!!** <br/><br/> 17143(못품) : 낚시꾼 문제인데 이건 다른사람 풀이를 봐도 나랑 다 그냥 비슷비슷한데 내꺼가 왜 틀린지를 모르겠다. 예제는 다 맞는데 코드 돌리자마자 틀렸다고하니 좀 허탈하네.. 1%도 못가는건 좀.. 그리고 너무 효율을 미리 다 생각해서 짜지말고 그냥 구현 자체만을 생각해야 할 수도.. 일단 다른거 먼저 해보자. <br/><br/> 17140 : 간단한 구현 문제였다. 이것도 마찬가지로 항상 문제를 잘 읽고, **조건!!도 꼭 봐야한다** <br/><br/> 17142(못품) : 계속 뭔가 문제 하나를 해결하지 못해서 풀지 못하네;; 왜이러지 계속 <br/><br/> 17779 : 생각보다 for문을 많이써도 시간초과가 나지 않네. 일단 최대한 효율은 고려하면서 코드를 짜되, **먼저 for문으로 만들 수 있는건 빨리 만드는게 좋은 듯하다**. 그리고 이 문제는 조건만 잘 살펴보고 그대로 구현하는 문제다. <br/><br/> 17837 : 와 진짜 문제 복잡한거 같다. 그래도 이전에 풀이법 중 **2차원 행렬에서 element에 deque를 넣을 수 있다는 것**을 알게 되어서 이 문제에서 써먹을 수 있었다!! 아주 뿌듯하다. 이 문제도 구현 문제라서.. 문제를 잘 읽고 조건에 따라 구현하면 됬는데, 말을 쌓는 개념을 위에 있을 수록 index가 0에 가깝고 아래에 있을 수록 index가 최대가 된다고 설정하고 풀었다.  |