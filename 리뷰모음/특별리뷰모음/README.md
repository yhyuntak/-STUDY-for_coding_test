# 코딩 테스트 준비용 알고리즘 특별 리뷰 모음 :smirk:

표로 문제에 대한 소감을 한줄로 작성하자.

|날짜| 리뷰 |
|:--:|:--:| 
|221007|  14889 : 일반적으로 중복없이 조합을 **순서대로(오름차순 혹은 내림차순)** 구할 땐, DFS와 백트래킹을 이용한 방법이 효율적이다. 단, 순서 없이 조합을 고르는 것은 permutations를 사용하자. :ok_woman: <br/><br/> 14890 : 완전 그냥 구현 문제. 문제 잘 읽고 잘 따라서만 하면 쉽게 풀 수 있는데 계속 세세한거 하나하나를 놓쳐서 시간이 오래걸린다. <br/><br/>  15683 : 이거 까먹었다.. 중요한게 뭐였는지.. <br/><br/> 15684(못품) : **구현 및 시뮬레이션을 할 땐, 최대한 2차원 행렬을 사용하려고 노력하자.** dict을 쓰면 결국 0(N)이 걸리니까 주소를 pointing하는 배열이 훨씬 시간적으로 효율적이다. **-꼭 다시보자. 2차원 행렬을 어떻게 dfs에서 쓸건지 보여준다.**<br/><br/> 16235 : **2차원 행렬에 deque 객체가 들어갈 수 있는 것을 처음 알았다.** 나무의 나이의 순서를 고려해야했던 문제인데, deque를 써서 appendleft를 사용할 수 있었다. 그리고 효율을 추구하기 위해서 계절끼리 묶을 수 있는 것들을 묶어야한다. <br/><br/> 20057 : 나만의 방법으로 **나선형으로 배열을 훑는 것**을 만들었다. 꼭 볼 것. 그리고 문제를 잘 읽고 그대로 따라서 구현하는 것을 꼭 고려하자. **문제 좀 잘 읽자!!!** <br/><br/> 17143(못품) : 낚시꾼 문제인데 이건 다른사람 풀이를 봐도 나랑 다 그냥 비슷비슷한데 내꺼가 왜 틀린지를 모르겠다. 예제는 다 맞는데 코드 돌리자마자 틀렸다고하니 좀 허탈하네.. 1%도 못가는건 좀.. 그리고 너무 효율을 미리 다 생각해서 짜지말고 그냥 구현 자체만을 생각해야 할 수도.. 일단 다른거 먼저 해보자. <br/><br/> 17140 : 간단한 구현 문제였다. 이것도 마찬가지로 항상 문제를 잘 읽고, **조건!!도 꼭 봐야한다** <br/><br/> 17142(못품) : 계속 뭔가 문제 하나를 해결하지 못해서 풀지 못하네;; 왜이러지 계속 <br/><br/> 17779 : 생각보다 for문을 많이써도 시간초과가 나지 않네. 일단 최대한 효율은 고려하면서 코드를 짜되, **먼저 for문으로 만들 수 있는건 빨리 만드는게 좋은 듯하다**. 그리고 이 문제는 조건만 잘 살펴보고 그대로 구현하는 문제다. <br/><br/> 17837 : 와 진짜 문제 복잡한거 같다. 그래도 이전에 풀이법 중 **2차원 행렬에서 element에 deque를 넣을 수 있다는 것**을 알게 되어서 이 문제에서 써먹을 수 있었다!! 아주 뿌듯하다. 이 문제도 구현 문제라서.. 문제를 잘 읽고 조건에 따라 구현하면 됬는데, 말을 쌓는 개념을 위에 있을 수록 index가 0에 가깝고 아래에 있을 수록 index가 최대가 된다고 설정하고 풀었다. <br/><br/> 17822 : 원판 돌리는 문제. 문제를 또 잘 안읽어서 중간 중간 이상한 결과들이 나왔다 ㅎ.. 정신차리자~~ 그리고 원판을 돌리는건 조건에 힌트가 아예 나와있었다. [i,j]로 하는 걸 보니 처음엔 2차원 배열로 해야하나 싶었지만, 원판 속 숫자들의 수가 4개로 고정이 아닌 것을 보고 **deque로 생각을 바꿨다. 원판을 돌리는 문제같은 느낌은 queue를 쓰니까 너무너무 편하게 해결할 수 있었다.** 그리고 평균 구하는 과정에서 divisionZero 에러가 나서 봤더니 아마 전부 'x'가 됬는데도 로직이 돌아가서 그런 것 같아서 조건을 바꿔주었다. <br/><br/> **17825(아예 잘못 품)** : 이건 아예 방향을 잘못 잡은거 같다. 나중에 힌트를 얻고 다시 풀어보자. <br/><br/> 20061 : 100분이나 걸린 문제다.. 진짜 구현하는데 너무 오래걸린다~~ <br/><br/> **19236(못품-꼭보자**) : dfs를 이용해서** 백트래킹하는 핵심은 백트래킹을 하고 싶은 것의 r,c 값을 입력으로 사용하는 것**이다! 진짜 너무 중요하다. 그리고 **조건문을 묶어서 사용할** 수 있다. 그리고 **여러 조건을 for문으로 묶는 것도 가**능하다. 아이디어가 너무 좋다. **꼭 복습할 것** <br/><br/> 19237(못품) : 예제,반례등 다 맞는데 시작하자마자 틀렸다고 한다.. 왜지..? 이유도 모르겠다.. <br/><br/> 19238 : 구현은 다했는데 계속 시작하자마자 틀렸다. 그 이유는 2가지였는데, 첫번째는 bfs를 하게되면 visit[next] = visit[present]+1 이런 식으로 할 때가 있는데, 처음 시작이었던 곳이 2로 반환될 때가 있다. 이게 문제가 발생하는 원인 1 이었고 이걸 해결하자 원인 2가 발생했다. 는 승객의 출발점과 택시의 위치가 겹치면 거리가 0 인데 그냥 조건에 내가 if min_val = 0 : break 라는 조건을 걸어놔서 문제가 발생했다. 아.. 이것도 다 문제에 자세하게 나와있는건데.. 진짜ㅜㅜ.. <br/><br/> 20055 : 컨베이어 벨트 문젠데, deque를 이용하면 간단히 풀린다. 이건 쉽다. <br/><br/> 20058 : 이건 구간을 쪼개서 90도 돌리는 것의 아이디어만 가져가도록 하자. **꼭 볼 것!!** <br/><br/> 21609 : 문제는 항상 다푸는데.. 사소한게 하나가 문제다 항상.. **BFS로 그룹군을 만들때 중복그룹군이 생길 수 있다는 것을 항상 염두에 둘 것!** 그리고 이 문제에서 무지개블록은 모든 그룹에 속할 수 있기 때문에 visit 2차원 배열의 무지개 블록 위치는 항상 0으로 만들어둘 필요가 있다. **그리고 그래프를 회전하는 방법을 좀더 간략하게 만들어 봤으니 확인하자.** <br/><br/> 21611 : 와 진짜 어렵다 ㅋㅋㅋ 최근으로 올수록 점점더 문제가 어려워지는거 같은데..? 회전하는게 너무 어렵네 계속.. 그리고 반례가 너무 많은 듯함.. 50%까진 통과했는데 더이상 뭐가 문제인진 잘 모르겠다.. 일단 넘기되, 이 문제에서 알게된 것은 구현하게되면 **한 단계 단계씩 작은 테스트 케이스를 만들어서 실험**해보면 좋은 것 같다. 뭐가 문제인지 보임. 그래서 겨우 50%는 넘기긴 했다.  <br/><br/> 23289 : ㅋㅋㅋ 3시간 반이나 걸렸다!! 너무 문제가 더럽다.. 솔직히.. 이 문제를 풀면서 가장 핵심적인 것은 벽세우는 것이었는데, 처음엔 list로 했다가 시간초과가 발생했다. 꼭 무조건 2차원 배열을 먼저 생각하도록 하자. 그리고 한 위치에 2개가 들어갈 수 있다는 것도 꼭 생각에 넣어놓자. 그래서 3차원 배열을 사용했다. 그리고 나머지는 문제가 너무 길어서 중간에 뭘 해야하는질 까먹어.. 문제는 다 읽고 푸는게 맞는 것 같다. 그리고 변수를 잘 사용하도록 하자. 진짜 어렵다기보단 너무 힘들었다.. <br/><br/> 설명에 세세한 조건들이 다 존재하는 이유가 있다. 꼭 꼼꼼히 살피면서 코딩에 임하자. |